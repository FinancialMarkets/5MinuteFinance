---
title: "The Pairs Trade"
author: "[GitHub Contributors](https://github.com/FinancialMarkets/5MinuteFinance/graphs/contributors)"
# logo: misq.png
# css: 5min_mod.css
output: html_document
runtime: shiny
smaller: true
---

<!-- Much of the text and code in this presentation is from here: https://mattbrigida.shinyapps.io/chapter7_pairs_trade/pairs_trade.Rmd  -->

## Market Neutral/Statistical Arbitrage

The pairs trade is a market neutral/statistical arbitrage quantitative trading strategy. What does this mean?

- *Market neutral*: Market risk is removed in the trading strategy.  Returns on your pairs trade should be uncorrelated with market returns.
- *Stat arb*: We find a statistical relationship between two assets, and then we wait for the relationship to behave differently.  We then trade to profit when the relationship begins to hold again.  This is a loose use of the term 'arbitrage,' and is not an arbitrage in the strict sense.

This strategy can be thought of as the opposite of Markowitz mean/variance optimization, which reduces firm specific risk but leaves market risk in our portfolio. 

<div class="MIfooter"><img src="mi.png" style="height:50px;"></div> 

## The Law of One Price

The 'Stat Arb' aspect of the pairs trade employs the **law of one price** (**LOP**).  This law says that if two securities have the same payoff in all states of the world, then the two securities must have the same price. 

-  This is enforced by arbitrage. 
-  Say the price of security *A* is greater than *B*, and they have the same payoff. You could sell *A* and buy *B*, earning \$*Aâˆ’B*, but the payoffs (being the same) will net to \$0.

<div class="MIfooter"><img src="mi.png" style="height:50px;"></div> 

## No One Way

There is no single way to implement the pairs trade. This is an active area of research, providing you with a venue to create your own strategy.  Following are the general steps of the pairs trade, and your method in any step can be different from methods employed by others.

#.  Choose a universe of pairs.
#.  Statistically determine the normal relationship between each pair (estimation period).
#.  Over a later (separate) trading period, watch the pairs to see if they deviate from their estimation period behavior.  If any do, trade the pair.  Close pairs trades for any open pair that returns to normal (or close pairs due to stop losses).
#.  Evaluate strategy performance and alter the methods in the previous steps.


<div class="MIfooter"><img src="mi.png" style="height:50px;"></div> 

## Your Own Method

The key to the pairs trade is how you implement the above structure.  Here are a few questions to consider:

-  What metric makes a pair acceptable (same industry, same country, etc.)?  How similar do the asset beta coefficient need to be?
-  How will you define the 'normal' statistical relationship?
-  How far does the pair have to deviate from its normal behavior before you enter the trade?  When do you exit the trade (either take profits or cut losses)?

We'll implement a version of the pairs trade in the following slides, which will give one approach to these questions.  

<div class="MIfooter"><img src="mi.png" style="height:50px;"></div> 

## [Gatev et al (2008)](http://www-stat.wharton.upenn.edu/~steele/Courses/434/434Context/PairsTrading/PairsTradingGGR.pdf)

This is a fairly simple application of the pairs trade.  You can see an implementation in R in [the code for this presentation](https://github.com/FinancialMarkets/5MinuteFinance/blob/master/Equity/pairs_trade/pairs_trade.Rmd).

*Estimation Period* 

- Given a stock pair, we first calculate normalized prices (cumulative returns) over some past period, so both stock prices are on the same scale.

- We then calculate the average squared difference between the prices, known as the average squared deviation, as well as the standard deviation of the squared deviations.  These two statistics (mean and standard deviation) allow us to categorize normal -- and abnormal -- behavior for a pair.  


<div class="MIfooter"><img src="mi.png" style="height:50px;"></div> 


## [Gatev et al (2008)](http://www-stat.wharton.upenn.edu/~steele/Courses/434/434Context/PairsTrading/PairsTradingGGR.pdf)

*Trading Period*

- Over a separate (later) period, we recalculate normalized prices and monitor the squared deviation.

-  If the squared deviation exceeds two standard deviations from its average, we open a pairs trade.  To do so, we buy the underperforming stock and short the better performing stock.

- When the spread goes to zero (the normalized prices cross), we close the pairs trade -- exiting our trades in the individual stocks.  

<div class="MIfooter"><img src="mi.png" style="height:50px;"></div> 

## Estimation Period Application

The app on the slide 10 allows you to chart normalized prices for any pair and estimation period you choose.  In fact, later in the presentation, trading period profits will be calculated based on the pair and estimation period in the slide 10.

*Good Pair: XOM and CVX* 

-  You want pairs with normalized prices which stay close to each other -- separating and crossing again.  A good example is the default pair, XOM and CVX.  

-  These pairs will have low average squared deviations and standard deviations.  

## Estimation Period Application

*Bad Pair: XOM and PFE*

-  Replace CVX with PFE and you'll see what a bad pair looks like.  The normalized prices move independently, and our pair statistics are high.

-  Note, by the **LOP**, XOM and CVX make a good pair (both integrated oil and gas firms).  However, PFE (Pfizer) is a pharmaceutical company, which has very different assets than an oil and gas firm.  Thus, in addition to our statistics, it helps to ask if the pair makes economic (LOP) sense.  

- Choose your pair, and estimation period, and click "Go".  The app will then calculate the estimation period parameters, and use these to trade the pair and calculate profit over the subsequent trading period.  

##

<!-- Estimation Period -->


```{r, messsage=FALSE, warning=FALSE, echo = FALSE, error = FALSE}
#{{{

library(dygraphs)
library(quantmod)

shinyUI(fluidPage(
    ## titlePanel("submitButton example"),
    fluidRow(
        column(3, wellPanel(
                      dateInput("estim_period_start", "Estimation Period Start", value = "2015-08-01"), 
                      dateInput("estim_period_end", "End", value = "2016-01-01"), 
                      textInput("ticker1", "First Stock Ticker", value = "XOM"),
                      textInput("ticker2", "Second Stock Ticker", value = "CVX"),
                      actionButton("go", "Go")
                  )),

        column(9,
               renderDygraph({
                   stockVals <<- eventReactive(input$go, {
                       from <- input$estim_period_start
                       to <- input$estim_period_end
                       
                       ## The code below to calculate an xts object of returns is from an SO or Quant.SE post.  I need to find it and cite.
                       env <- new.env()
                       Symbols <- c(input$ticker1, input$ticker2)
                       getSymbols(Symbols = Symbols, env = env, from = from, to = to)
                       args <- eapply(env = env, FUN = function(x){ClCl(x)})[Symbols]
                       returns <- na.omit(do.call(what = merge, args = args))
                       colnames(returns) <- Symbols
                       ## convert reutrns to  normalized prices
                       norm.prices <<- cumsum(returns)
                       
                       norm.prices.df <<- as.data.frame(norm.prices)

                       from.t <- input$estim_period_end + 1
                       to.t <- Sys.Date()

                       ## The code below to calculate an xts object of returns is from an SO or Quant.SE post.  I need to find it and cite.
                       env.t <- new.env()
                       getSymbols(Symbols = Symbols, env = env.t, from = from.t, to = to.t)
                       args <- eapply(env = env.t, FUN = function(x){ ClCl(x) })[Symbols]
                       returns.t <- na.omit(do.call(what = merge, args = args))
                       colnames(returns.t) <- Symbols
                       returns.t <<- returns.t
                       ## convert returns to  normalized prices
                       norm.prices.t <<- cumsum(returns.t)
                   })

                   stockVals()
                   dygraph(norm.prices)
                                        #}}}
               }),


               renderPrint({    
                   
                   stockVals()
                   from <- input$estim_period_start
                   
                   ## Calculate the estimation period parameters (the average squared deviation and the standard deviation of the squared deviations):
                   asd.e <<- mean(( norm.prices.df[,1] - norm.prices.df[,2])^2 )
                   ssd.e <<- sd(( norm.prices.df[,1] - norm.prices.df[,2])^2 )
                   cat("The average squared deviation is", asd.e ,"\n")
                   cat("The standard deviation of the squared deviations is:", ssd.e ,"\n")
               })
               )
    )
)
)
#}}}
```



<div class="MIfooter"><img src="mi.png" style="height:50px;"></div> 


## Trading Period

We monitor how many standard deviations the squared deviation is from its average squared deviation. 

-  When the squared deviation differs from its average by a threshold number of standard deviations, we'll initiate a pairs trade. 

-  We close the pairs trade when the squared deviation drops below another threshold number of standard deviations.


<div class="MIfooter"><img src="mi.png" style="height:50px;"></div> 

## Thresholds

Implementation of the trade requires thresholds at which you open and close your pairs trade. Gatev et al (2008) enter the trade at 2 standard deviations wide, and they close the trade when the prices cross.  

-  You can observe what others have done, but there is no theoretical reason why the threshold should be 2 instead of 1.9 or 2.1. You can, of course, run different thresholds over historical data and see what was optimal. 

-  The app below allows you to try different thresholds and see the profit.

-  Whatever thresholds were optimal may not be optimal over later trading periods.  

<div class="MIfooter"><img src="mi.png" style="height:50px;"></div> 


## Adjusting for Market Risk


If the two stocks are really good substitutes for one another, they likely have similar levels of market risk (measured by [beta coefficients](http://www.5minutefinance.org/concepts/the-capital-asset-pricing-model)). You can therefore buy and short equal dollar amounts. 

- However, if the stocks have substantially different beta coefficients (first, reconsider if it is a good pair), you may want to weight your investment in each so that the beta of the position is close to zero.

- For example, say stock A has a beta of 0.8 and stock B has a beta of 1.2. Then you want to invest $\frac{1.2}{0.8} = 1.5$ times as much in stock A as B. So, say you invest \$10,000 in stock B, then you want to invest \$15,000 in stock A.

Gatev et al (2008) do not make a market risk adjustment and so neither will the results below.  


<div class="MIfooter"><img src="mi.png" style="height:50px;"></div> 



##

```{r, messsage=FALSE, warning=FALSE, echo = FALSE}
#{{{
inputPanel(

    sliderInput("buy", "Enter Trade at Threshold:", min = .5, max = 4, value = 2, step = .1, animate = FALSE),

    sliderInput("sell", "Close Trade at Threshold", min = 0, max = 1.5, value = 0.5, step = .1, animate = FALSE)
)

renderDygraph({
                   stockVals()

          from <- input$estim_period_start
          
numSD <- ( (norm.prices.t[,1] - norm.prices.t[,2])^2 - asd.e ) / ssd.e

trade <- rep(0, length(seq_along(numSD)))
position <- rep(0, length(seq_along(numSD)))

for (i in 2:length(seq_along(numSD))) {
    if (numSD[i] > input$buy && numSD[i-1] < input$buy && position[i-1] < 1) {
        trade[i] <- 1
    } else {
        if (numSD[i] < input$sell && numSD[i-1] > input$sell && position[i-1] == 1) {
            trade[i] <- -1
        } else {
            trade[i] <- 0
        }
    }
    position[i] <- trade[i] + position[i-1]
}

### Now add profit calculation here ----
## First calculate how many standard deviations we made -----
stdev.when.trade <- trade * numSD
profitSD <- sum(stdev.when.trade)

if(position[length(position)] == 1) {
    ## have to subtract SD when entered last trade, still get some negatives though with positive profit.
    profitSD = profitSD - (numSD[length(numSD)] - as.numeric(stdev.when.trade[tail(which(stdev.when.trade != 0), 1)]))
} else {
    profitSD = profitSD
    }

## Now calculate the percent profit per standard deviation ----
### square root of the standard dev (now in units of deviations instead of sq devs) of squared devs times the number of standard devs
#### Don't know if this is the correct calculation -- probably not.
## amt.devs.percent <- 100 * sqrt(ssd.e) * profitSD

## This % profit calculation looks correct ----
## instead, just look at spread on that day in norm.prices.t
spread.when.trade <- trade * abs(norm.prices.t[,1] - norm.prices.t[,2])
profit.percent <- sum(spread.when.trade)


if(position[length(position)] == 1) {
    profit.percent = profit.percent - abs(norm.prices.t[dim(norm.prices.t)[1], 1] - norm.prices.t[dim(norm.prices.t)[1], 2])
} else {
    profit.percent = profit.percent
    }

profit.percent <- profit.percent * 100

data.dygraph <- cbind(numSD, as.xts(position, order.by = index(numSD)))
names(data.dygraph) <- c("# of Standard Deviations", "Position: 0 = no trade, 1 = trade on")

dygraph( data.dygraph  , main = paste0(colnames(returns.t)[1], " & ", colnames(returns.t)[2], ":  Profit in Standard Deviations: ", round(profitSD, 2) , ", Percent Profit ", round(profit.percent, 2), "%"), ylab = "# Standard Deviations") %>%
dyOptions(colors = RColorBrewer::brewer.pal(2, "Set1"))
#}}}    

})
```

##  Opening/Closing a Trade

Using the default pair, dates, and thresholds, you can see we open a pairs trade in the beginning of February (and close it in March).  How do we know which stock to buy and which to sell? 

-  In the next slide the normalized prices are charted over the trading period.  You can see when we open the trade, CVX's normalized price is below XOM's.  Therefore to open the trade we buy CVX and short an equal dollar amount of XOM.  

-  To close the pairs trade in March, we sell all of our CVX and buy back all of our XOM.

<div class="MIfooter"><img src="mi.png" style="height:50px;"></div> 

##

```{r, messsage=FALSE, warning=FALSE, echo = FALSE}
#{{{
library(dygraphs)
renderDygraph({
  stockVals()
  from <- input$estim_period_start
  dygraph(norm.prices.t, main = "Normalized Prices Over the Trading Period") 
#}}}    
})
```

<div class="MIfooter"><img src="mi.png" style="height:50px;"></div> 

## Effect of Time Intervals 

If we are using closing trade prices, as we do with daily data, we get our signal at time $t$ closing prices and trade at time $t+1$ opening prices. Therefore, we are never sure of the number of standard deviations at which we'll open the trade. 

-  If we were basing our signal on intraday bid/ask prices, then we would open and close our trades much closer to our thresholds.

-  The difference between our signal and trade prices is known as [slippage](https://en.wikipedia.org/wiki/Slippage_(finance)).

-  The estimated profits in this presentation correctly trade at later prices, thus accounting for slippage.

<div class="MIfooter"><img src="mi.png" style="height:50px;"></div> 


## Large Trading Period Standard Deviations 

For some pairs we'll see the average squared deviation during the trading periods is more than 30 standard deviations from the average during the estimation period. This seems very unlikely given Chebyshev's inequality, $P(|X - \mu| \geq k\sigma) \leq \frac{1}{k^2}$ where $X$ is a random variable, with finite mean $\mu$ and standard deviation $\sigma$, and $k$ is a real number.

-  Plugging in 30 for $k$, the probability that a random variable deviates from its mean by 30 standard deviations is less than 0.11%. So why can we get such large deviations from the mean?

-  See the next slide for the answer.

## Large Trading Period Standard Deviations

The answer is fundamental to understanding the risks in the pairs trade -- and prediction in general. Applying Chebyshev's inequality as we did above implies that the mean and standard deviation of our squared deviation did not change over time (from our estimation to trading period). However, they will change, often substantially.

-  For instance, what would you expect if you estimate the parameters for your XOM and CVX pair and then during your trading period the BP Gulf oil spill occurs? Obviously, your parameters are no longer relevant, and the spread would increase well over 30 standard deviations.

-  This highlights an important point in pairs trading: you should ensure that there is no fundamental reason for the spread divergence, such as a merger or acquisition, prior to entering the trade.

<div class="MIfooter"><img src="mi.png" style="height:50px;"></div> 

## Credits and Collaboration

Click the following links to see the [code](https://github.com/FinancialMarkets/5MinuteFinance/blob/master/Trading_and_Market_Structure/pairs_trade/pairs_trade.Rmd), [line-by-line contributions to this presentation](https://github.com/FinancialMarkets/5MinuteFinance/blame/master/Trading_and_Market_Structure/pairs_trade/pairs_trade.Rmd), and [all the collaborators who have contributed to 5-Minute Finance via GitHub](https://github.com/FinancialMarkets/5MinuteFinance/graphs/contributors).

Learn more about how to contribute [here](http://www.5minutefinance.org/how-to-contribute).

<div class="MIfooter"><img src="mi.png" style="height:50px;"></div> 
